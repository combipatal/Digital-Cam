// capture.v
//
// This module captures incoming pixel data and is synchronous to the
// 24 MHz clock generated by the XCLK pin of the OV7670 camera.
//
// The OV7670 outputs 30FPS in VGA.
//
module capture 
    (
    input  wire        i_pclk,     // 24 MHz; sourced from OV7670 camera
    input  wire        i_rstn,     // synchronous active low reset
    input  wire        i_cfg_done, // cam config done flag
    output wire        o_status,   // asserted when capturing

    // OV7670 camera interface
    input  wire        i_vsync,    // active-high, indicates start of frame
    input  wire        i_href,     // active-high, indicates row data transmission
    input  wire [7:0]  i_data,     // pixel data from camera
    
    // FIFO write interface   
    output reg         o_wr,       // fifo write enable
    output reg  [11:0] o_wdata,    // fifo write data; {red, green, blue}

    output wire        o_sof,       // start of frame flag
	 output wire        vsync_posedge,
    output wire        vsync_negedge
    );

    reg        nxt_wr;
    reg [11:0] nxt_wdata;
    reg [7:0]  byte1_data, nxt_byte1_data;

    reg        pixel_half, nxt_pixel_half;

    reg [1:0]  STATE, NEXT_STATE;
    localparam STATE_IDLE    = 0,
               STATE_ACTIVE  = 1,
               STATE_INITIAL = 2;

    initial begin
        o_wr  = 0;
        STATE = STATE_INITIAL;
    end
    assign o_status = (STATE == STATE_ACTIVE);
	 
    reg vsync_ff1, vsync_ff2, vsync_ff3;

// VSYNC 신호 안정화 및 엣지 감지 로직 수정
always @(posedge i_pclk or negedge i_rstn) begin
    if (!i_rstn) begin
        vsync_ff1 <= 1'b0;
        vsync_ff2 <= 1'b0;
        vsync_ff3 <= 1'b0;
    end else begin
        vsync_ff1 <= i_vsync;
        vsync_ff2 <= vsync_ff1;
        vsync_ff3 <= vsync_ff2;
    end
end

// rising edge 감지 (active-high 신호 기준)
assign vsync_posedge = (vsync_ff2 == 1'b1) && (vsync_ff3 == 1'b0);

// falling edge 감지 (active-high 신호 기준)
assign vsync_negedge = (vsync_ff2 == 1'b0) && (vsync_ff3 == 1'b1);

// OV7670은 일반적으로 VSYNC falling edge에서 프레임 시작
assign o_sof = vsync_negedge;
    // **** Next State Logic ****
    //
    always@* begin
        nxt_wr           = 0;
        nxt_wdata        = o_wdata;
        nxt_byte1_data   = byte1_data;
        nxt_pixel_half   = pixel_half;
        NEXT_STATE       = STATE;

        case(STATE)

            STATE_INITIAL: begin
                NEXT_STATE = (i_cfg_done && o_sof) ? STATE_IDLE : STATE_INITIAL;
            end

            // camera not outputting 
            STATE_IDLE: begin
                nxt_wr         = 0;
                nxt_pixel_half = 1;
                // IDLE 상태는 프레임이 막 시작되었음을 의미하므로,
                // 바로 ACTIVE 상태로 전환하여 데이터 입력을 준비합니다.
                NEXT_STATE = STATE_ACTIVE;
            end	

            // camera outputting display data
            STATE_ACTIVE: begin
                if(i_href) begin
                    nxt_pixel_half = ~pixel_half;

                    // RGB444: Second Byte (green, blue)
                    if(pixel_half) begin
                        nxt_wr    = 1;
                        nxt_wdata = {byte1_data[3:0], i_data[3:0]}; // R[3:0], G[3:0], B[3:0]
                    end

                    // RGB444: First Byte (red, green)
                    else begin
                        nxt_wr              = 0;
                        nxt_byte1_data[7:0] = i_data; // Store R and G bits
                    end          
                end
                NEXT_STATE = (o_sof) ? STATE_IDLE : STATE_ACTIVE;
            end

        endcase
    end

    always@(posedge i_pclk) begin
        if(!i_rstn) begin
            o_wr         <= 0;
            o_wdata      <= 0;
            byte1_data   <= 0;
            pixel_half   <= 0;
            STATE        <= STATE_INITIAL;
        end
        else begin
            o_wr         <= nxt_wr;
            o_wdata      <= nxt_wdata;
            byte1_data   <= nxt_byte1_data;
            pixel_half   <= nxt_pixel_half;
            STATE        <= NEXT_STATE;
        end
    end

endmodule
