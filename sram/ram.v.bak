module sram(

	output reg we_n,							// write enable, 쓰기 신호
	output reg oe_n,							// output enable , 출력 신호
	output reg ce_n,							// chip enable 칩을 키는 신호
	output [19:0] addr_out,				// read/write address 
	output reg[15:0] data_out,				// 출력할 data

	inout [15:0] sram_dq,				// 읽고 출력할 data  
	
	input [15:0] data_in,				// 저장할 data
	input [19:0] addr_in,				// 저장할 주소
	input write_req,						// 쓰기 명령
	input read_req,						// 읽기 명령
	input rst_n,							// reset
	input clk);								// clk

	// 준비상태 -> we = 1, oe = 1, ce_n = 0	
	// fsm 
	// idle state -> setup_write (address & data 값을 설정 but we = 1)
	// -> execute_write (We = 0) -> finsh_write (we = 1)
		
	parameter IDEL = 3'b000;
	parameter SETUP_WRITE = 3'b001;
	parameter EXECUTE_WRITE = 3'b010;
	parameter FINSH = 3'b011;
	
	parameter SETUP_READ = 3'b100;
	parameter EXECUTE_READ = 3'b101;
	parameter CAPTURE_READ  = 3'b110;

	reg [2:0] state;															 		// 현재상태
	
	reg data_signal;																	// data를 출력할 건지 말건지 판단
	reg WR_signal;																		// Write 와 Read 구별 신호
	
	// sram_dq 가  write_signal 이 on 이라면 data_in을 입력하고, write_signal 이 off( read ) 라면 z를 유지하여 데이터를 받는다.
	
	assign sram_dq = (WR_signal) ? data_in : 16'hzzzz;						// 이게 write 신호만으로 sram_dq를 구분해도 되는건가 불안정하지 않나?
	//assign data_out = (data_signal) ? sram_dq; 16'hzzzz; 
	assign addr_out = addr_in;
	
	always @(posedge clk or negedge rst_n) begin
		if (!rst_n) begin
			state <= IDEL;
			we_n <= 1'b1;																// off
			oe_n <= 1'b1;																// off
			ce_n <= 1'b1;																// off

		end
		
		else begin
			
			case (state)
			
				IDEL : begin															//	we_n 이 1( off ), write_signal = 0 (off) 
						we_n <= 1'b1;
						oe_n <= 1'b1;
						ce_n <= 1'b1;													// chip_enable off
						WR_signal <= 1'b0;
						
						if (write_req && !read_req) begin
							state <= SETUP_WRITE;
							ce_n <= 1'b0;
						end
						
						else if(read_req && !write_req) begin
							state <= SETUP_READ;
							ce_n <= 1'b0;
						end
				end
				// WRITE 
				SETUP_WRITE : begin								// we_n = 1 ( off )  , WR_signal = 1 (write) 
						//we_n <= 1'b1;			 
						WR_signal <= 1'b1;							// assign sram_dq = date_in;
						state <= EXECUTE_WRITE;
				end
				
				EXECUTE_WRITE : begin							// we_n = 0 ( on ) , WR_signal = 1 (write)	
						we_n <= 1'b0;
						//WR_signal <= 1'b1;						// writing now
						state <= FINSH;
				end
				
				// READ 
				SETUP_READ : begin								//  바뀐 주소를 할당해주기 위한 1 clk지연
						state <= EXECUTE_READ;
						data_signal <= 1'b1;						// 출력 데이터를 on
				end
				
				EXECUTE_READ : begin
						oe_n <= 1'b0;								// output enable on						
						state <= CAPTURE_READ;
				end
				
				CAPTURE_READ : begin
						data_out <= sram_dq;						// data_out (reg) 에 sram_dq(wire) 대입
				end	
				FINSH : begin										// finsh 1 clk, we_n = 1 (off),oe_n <= 1 (off)WR_signal = 0 (read)
						we_n <= 1'b1;
						oe_n <= 1'b1;
						WR_signal <= 1'b0;
						state <= IDEL;								
				end
				
				default : state <= IDEL;
			endcase
		end
	end
endmodule
						